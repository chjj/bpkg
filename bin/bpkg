#!/usr/bin/env node

/*!
 * bpkg - bundler for node.js
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bpkg
 */

'use strict';

const assert = require('assert');
const bpkg = require('../');
const {argv, stdin, stdout, stderr, exit} = process;

/*
 * Constants
 */

const VERSION = '0.0.0';

const HELP = `
  Usage: bpkg [options] [file]

  Options:

    -v, --version           output the version number
    -o, --output <file>     output file or directory (default: stdout)
    -e, --env <name>        set environment, node or browser (default: node)
    -n, --node              set environment to node
    -b, --browser           set environment to browser
    --extensions <a,b,..>   list of extensions (default: .js,.mjs,.json,.node)
    -f, --browser-field     force usage of package.json "browser" field
    -i, --ignore-missing    ignore missing modules during compilation
    -c, --collect-bindings  include bindings separately
    -x, --exclude-source    exclude c++ source in multi mode
    -l, --no-license        do not place licenses at the top of the bundle
    -m, --multi             output module as multiple files
    -s, --single            build a single file without transpiling modules
    -u, --minify            minify bundle or files (using uglify-es)
    --exports               expose on module.exports for browser bundles
    --global                expose globally for browser bundles
    --name <name>           name to use for global exposure (default: pkg.name)
    -p, --plugins <a,b,..>  comma separated list of plugins
    --tar <file>            path to tar
    -h, --help              output usage information
`;

/*
 * Helpers
 */

function getArgs(argv) {
  assert(Array.isArray(argv));

  const args = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    assert(typeof arg === 'string');

    if (arg.startsWith('--')) {
      // e.g. --opt
      const index = arg.indexOf('=');
      if (index !== -1) {
        // e.g. --opt=val
        args.push(arg.substring(0, index));
        args.push(arg.substring(index + 1));
      } else {
        args.push(arg);
      }
    } else if (arg.startsWith('-')) {
      if (arg.length > 2) {
        // e.g. -abc
        for (let j = 1; j < arg.length; j++)
          args.push(`-${arg.charAt(j)}`);
      } else {
        // e.g. -a
        args.push(arg);
      }
    } else {
      // e.g. foo
      args.push(arg);
    }
  }

  return args;
}

async function readInput() {
  const out = [];

  let total = 0;

  return new Promise((resolve, reject) => {
    let onData, onError, onEnd;

    const cleanup = () => {
      stdin.removeListener('data', onData);
      stdin.removeListener('error', onError);
      stdin.removeListener('end', onEnd);
    };

    onData = (data) => {
      if (total > (100 << 20)) {
        onError(new Error('Too much code buffered.'));
        return;
      }

      total += data.length;
      out.push(data);
    };

    onError = (err) => {
      cleanup();

      try {
        stdin.destroy();
      } catch (e) {
        ;
      }

      reject(err);
    };

    onEnd = () => {
      cleanup();
      resolve(Buffer.concat(out));
    };

    stdin.on('data', onData);
    stdin.on('error', onError);
    stdin.on('end', onEnd);

    try {
      stdin.resume();
    } catch (e) {
      reject(e);
    }
  });
}

async function parseArgs() {
  const options = {
    __proto__: null,
    stream: stdout,
    input: null,
    output: null,
    code: null,
    env: 'node',
    extensions: ['.js', '.mjs'],
    browserField: false,
    ignoreMissing: false,
    collectBindings: false,
    excludeSource: false,
    noLicense: false,
    multi: false,
    single: false,
    minify: false,
    exports: false,
    global: false,
    name: null,
    plugins: [],
    tar: process.env.BPKG_TAR || 'tar',
    verbose: false
  };

  const args = getArgs(argv);

  for (let i = 2; i < args.length; i++) {
    const arg = args[i];

    let next = '';

    if (i + 1 < args.length)
      next = args[i + 1];

    switch (arg) {
      case '-v':
      case '--version': {
        stdout.write(VERSION + '\n');
        exit(0);
        break;
      }

      case '-o':
      case '--output': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.output = next;

        i += 1;

        break;
      }

      case '-e':
      case '--env': {
        if (next !== 'node' && next !== 'browser')
          throw new Error(`Invalid option for: ${arg}.`);

        options.env = next;

        i += 1;

        break;
      }

      case '-n':
      case '--node': {
        options.env = 'node';
        break;
      }

      case '-b':
      case '--browser': {
        options.env = 'browser';
        break;
      }

      case '--extensions': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.extensions.push(...next.split(','));

        i += 1;

        break;
      }

      case '-f':
      case '--browser-field': {
        options.browserField = true;
        break;
      }

      case '-i':
      case '--ignore-missing': {
        options.ignoreMissing = true;
        break;
      }

      case '-c':
      case '--collect-bindings': {
        options.collectBindings = true;
        break;
      }

      case '-x':
      case '--exclude-source': {
        options.excludeSource = true;
        break;
      }

      case '-l':
      case '--no-license': {
        options.noLicense = true;
        break;
      }

      case '-m':
      case '--multi': {
        options.multi = true;
        break;
      }

      case '-s':
      case '--single': {
        options.single = true;
        break;
      }

      case '-u':
      case '--minify': {
        options.minify = true;
        break;
      }

      case '--exports': {
        options.exports = true;
        break;
      }

      case '--global': {
        options.global = true;
        break;
      }

      case '--name': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.name = next;

        i += 1;

        break;
      }

      case '-p':
      case '--plugins': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.plugins.push(...next.split(','));

        i += 1;

        break;
      }

      case '--tar': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.tar = next;

        i += 1;

        break;
      }

      case '-V':
      case '--verbose': {
        options.verbose = true;
        break;
      }

      case '-h':
      case '--help': {
        stdout.write(HELP + '\n');
        exit(0);
        break;
      }

      default: {
        if (arg === '-') {
          if (options.input)
            options.output = null;
          else
            options.code = await readInput();
          break;
        }

        if (arg.length === 0 || arg[0] === '-')
          throw new Error(`Invalid argument: ${arg}.`);

        if (options.input)
          options.output = arg;
        else
          options.input = arg;

        break;
      }
    }
  }

  if (!options.input)
    options.input = '.';

  return options;
}

(async () => {
  let options;

  try {
    options = await parseArgs();
  } catch (e) {
    stderr.write(e.message + '\n');
    return 1;
  }

  const code = await bpkg(options);

  if (code)
    stdout.write(code + '\n');

  return 0;
})().then((code) => {
  process.exitCode = code;
  process.on('exit', () => exit(code));
}).catch((err) => {
  stderr.write(err.stack + '\n');
  exit(1);
});
